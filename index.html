<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Metro Platform Safety System</title>

<style>
body{
    background:#111;
    color:white;
    font-family:Arial;
    text-align:center;
}

#cameraContainer{
    position:relative;
    width:640px;
    height:480px;
    margin:auto;
}

video, canvas{
    position:absolute;
    top:0;
    left:0;
}

canvas{ pointer-events:none; }

button{ padding:8px 12px; margin:5px; }

.statusSafe{ color:lightgreen; }
.statusBreach{ color:red; font-weight:bold; }

#fineTab{ display:none; }
.record{
    border:2px solid red;
    margin:10px;
    padding:10px;
}
</style>
</head>

<body>

<h2>Metro Virtual Yellow Line Monitoring</h2>

<button onclick="showTab('monitor')">Monitoring</button>
<button onclick="showTab('fine')">Fine Tab</button>

<div id="monitorTab">

<div id="cameraContainer">
    <video id="video" width="640" height="480" autoplay muted></video>
    <canvas id="canvas" width="640" height="480"></canvas>
</div>

<br>

<label>Number of Curve Points:</label>
<input type="number" id="numPoints" min="2" max="10" value="3">
<button onclick="createSliders()">Create Points</button>

<div id="sliders"></div>

<br>

<label>Safe Side:</label>
<select id="safeSide">
    <option value="left">Left Safe</option>
    <option value="right">Right Safe</option>
</select>

<button onclick="lockSystem()">LOCK & START</button>

<h3 id="status" class="statusSafe">Configuration Mode</h3>

</div>

<div id="fineTab">
    <h2>Violation Records</h2>
    <div id="fineContainer"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>

<script>
window.onload = function(){

const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const statusText = document.getElementById("status");

let curvePoints = [];
let monitoring = false;
let cooldown = false;
let presenceStart = null;
let requiredStayTime = 1500; // 1.5 seconds

// Start camera
navigator.mediaDevices.getUserMedia({video:true})
.then(stream => video.srcObject = stream);

// Tab switch
window.showTab = function(tab){
    document.getElementById("monitorTab").style.display =
        tab==="monitor" ? "block" : "none";
    document.getElementById("fineTab").style.display =
        tab==="fine" ? "block" : "none";
}

// Create sliders
window.createSliders = function(){

    curvePoints = [];
    const slidersDiv = document.getElementById("sliders");
    slidersDiv.innerHTML = "";

    let n = parseInt(document.getElementById("numPoints").value);

    for(let i=0;i<n;i++){

        let container = document.createElement("div");

        let label = document.createElement("span");
        label.innerText = "Point "+(i+1)+" X ";
        container.appendChild(label);

        let x = document.createElement("input");
        x.type="range"; x.min=0; x.max=640;
        x.value=100+i*100;
        x.addEventListener("input", drawOverlay);
        container.appendChild(x);

        let labelY = document.createElement("span");
        labelY.innerText=" Y ";
        container.appendChild(labelY);

        let y = document.createElement("input");
        y.type="range"; y.min=0; y.max=480;
        y.value=250;
        y.addEventListener("input", drawOverlay);
        container.appendChild(y);

        slidersDiv.appendChild(container);
        curvePoints.push({x,y});
    }

    drawOverlay();
};

// Lock system
window.lockSystem = function(){
    monitoring = true;
    document.querySelectorAll("input").forEach(el=>el.disabled=true);
    document.getElementById("safeSide").disabled=true;
    statusText.innerText="Monitoring Active";
}

// Draw curve
function drawOverlay(){

    ctx.clearRect(0,0,640,480);

    if(curvePoints.length<2) return;

    ctx.beginPath();
    ctx.strokeStyle="yellow";
    ctx.lineWidth=4;

    ctx.moveTo(curvePoints[0].x.value,
               curvePoints[0].y.value);

    for(let i=1;i<curvePoints.length;i++){
        ctx.lineTo(curvePoints[i].x.value,
                   curvePoints[i].y.value);
    }

    ctx.stroke();
}
function isUnsafe(px, py){

    if(curvePoints.length < 2) return false;

    let safeSide = document.getElementById("safeSide").value;

    // Build polygon from curve + screen edge
    let polygon = [];

    // Add curve points
    for(let p of curvePoints){
        polygon.push([
            parseInt(p.x.value),
            parseInt(p.y.value)
        ]);
    }

    if(safeSide === "left"){
        polygon.push([0,480]);
        polygon.push([0,0]);
    } else {
        polygon.push([640,480]);
        polygon.push([640,0]);
    }

    return pointInPolygon([px,py], polygon);
}
function pointInPolygon(point, vs) {

    let x = point[0], y = point[1];
    let inside = false;

    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {

        let xi = vs[i][0], yi = vs[i][1];
        let xj = vs[j][0], yj = vs[j][1];

        let intersect =
            ((yi > y) != (yj > y)) &&
            (x < (xj - xi) * (y - yi) / (yj - yi) + xi);

        if (intersect) inside = !inside;
    }

    return inside;
}
function captureViolation(){

    if(cooldown) return;
    cooldown = true;

    let snapCanvas = document.createElement("canvas");
    snapCanvas.width = 640;
    snapCanvas.height = 480;

    let snapCtx = snapCanvas.getContext("2d");

    // Draw video
    snapCtx.drawImage(video, 0, 0, 640, 480);

    // Draw overlay line
    if(curvePoints.length >= 2){

        snapCtx.beginPath();
        snapCtx.strokeStyle = "yellow";
        snapCtx.lineWidth = 4;

        snapCtx.moveTo(curvePoints[0].x.value,
                       curvePoints[0].y.value);

        for(let i=1;i<curvePoints.length;i++){
            snapCtx.lineTo(curvePoints[i].x.value,
                           curvePoints[i].y.value);
        }

        snapCtx.stroke();
    }

    let imgData = snapCanvas.toDataURL("image/png");
    addFineRecord(imgData);
    setTimeout(()=>cooldown=false,3000);
}
function addFineRecord(imgData){

    let container = document.getElementById("fineContainer");

    let record = document.createElement("div");
    record.className = "record";

    let img = document.createElement("img");
    img.src = imgData;
    img.width = 200;

    let time = document.createElement("p");
    time.innerText = "Time: " + new Date().toLocaleString();

    let deleteBtn = document.createElement("button");
    deleteBtn.innerText = "Delete";
    deleteBtn.style.background = "darkred";
    deleteBtn.style.color = "white";

    deleteBtn.onclick = function(){
        record.remove();
    };

    record.appendChild(img);
    record.appendChild(time);
    record.appendChild(deleteBtn);

    container.prepend(record);

    showTab("fine");
}

// -------- POSE SETUP --------
const pose = new Pose({
    locateFile: (file) =>
        `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
});

pose.setOptions({
    modelComplexity: 0,
    smoothLandmarks: true,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});
pose.onResults(results => {

    drawOverlay();

    if(!monitoring) return;

    if(results.poseLandmarks){

        let leftHip = results.poseLandmarks[23];
        let rightHip = results.poseLandmarks[24];

        let px = ((leftHip.x + rightHip.x) / 2) * 640;
        let py = ((leftHip.y + rightHip.y) / 2) * 480;

        ctx.beginPath();
        ctx.arc(px, py, 10, 0, 2*Math.PI);
        ctx.fillStyle = "cyan";
        ctx.fill();

        let unsafe = isUnsafe(px, py);

        if(unsafe){

            statusText.innerText = "UNSAFE AREA OCCUPIED";
            statusText.className = "statusBreach";

            if(presenceStart === null){
                presenceStart = Date.now();
            }

            // If stayed long enough â†’ capture
            if(Date.now() - presenceStart > requiredStayTime){
                captureViolation();
                presenceStart = null; // reset after capture
            }

        } else {

            statusText.innerText = "SAFE";
            statusText.className = "statusSafe";

            presenceStart = null; // reset if person leaves area
        }
    }
});

// Attach camera to pose
const camera = new Camera(video, {
    onFrame: async () => {
        await pose.send({ image: video });
    },
    width: 640,
    height: 480
});

camera.start();
createSliders();

}
</script>

</body>
</html>
